# vector со small-object и copy-on-write оптимизациями

Реализация класса аналогичного `std::vector`, но
имеющий *small-object* и *copy-on-write* оптимизации.

*small-object* предполагает, что вектор умеет хранить небольшое число элементов
без динамической аллокации памяти.

*copy-on-write* предполагает, что
копирование/присваивание больших векторов не копирует все элементы само, а
откладывает копирование элементов до момента когда к объекту применят
модифицирующую операцию.

Реализуемый класс называется `socow_vector` и лежит в
хедере `socow-vector.h`. Он имеет два шаблонных параметра: тип хранимых
объектов и размер маленького буффера.

```cpp
template <typename T, size_t SMALL_SIZE>
class socow_vector;
```

Из-за наличия  *small-object* и *copy-on-write* оптимизаций, некоторые операции
имеют другую вычислительную сложность и/или предоставляют другую гарантию
безопасности исключений:

* Конструктор копирования и оператор присваивания работают
  за `O(SMALL_SIZE)`, а не за `O(size)`.
* Если размеры и `a` и `b` не больше `SMALL_SIZE`, `swap(a, b)` предоставляет
  базовую гарантию безопасности исключений, иначе – сильную.
* Если размеры и `a` и `b` не больше `SMALL_SIZE`, `a = b` предоставляет
  базовую гарантию безопасности исключений, иначе – сильную.
* Неконстантные
  операции `operator[]`, `data()`, `front()`, `back()`, `pop_back()`, `begin()`,
  `end()` работают за O(size) и удовлетворяют сильной гарантии
  безопасности исключений, если требуется копирование для *copy-on-write*, и за
  O(1) и nothrow иначе.
* Как и со стандартным вектором, `reserve` гарантирует, что
  выполение `reserve(n)` вставки в вектор не будет приводить к переаллокациям,
  пока размер <= `n`.

